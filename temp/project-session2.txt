









05/03/2023      Project
Advanced Databases



















Caspar DIMANCHE & Camille SIMON
L3 INT 3 – PROFESSOR: MS BEN LTAIFA

Caspar DIMANCHE & Camille SIMON – INT 3

Table of contents

I-    Introduction                         1
II-    Steps and results of the project             2-28
a.  First session                     2-16
i.  Part 0: Preparation              2-7
ii.  Part 1: Normalization            7-16
b.  Second session                   16-28
i.  Part 1: Index                16-21
ii.  Part 2: Views                22-23
iii. Part 3: Stored procedures and trigger   23-28
III-   Conclusion                         28












I-   Introduction

After having many lessons and TP sessions about the Advanced Databases course, it was time for a project! In this project, we were asked to work on a database filled by Poudlard’s information about students, the houses they are belonging to as well as the courses they are taking.
We had many missions, such as applying many SELECT queries on the database to familiarize with the data. After, we had to create a normalized database of this database, by deleting the duplicates and applying all the normalization’s rules.
Once the database was normalized, we had to deal with indexes by showing the benefits they are bringing, but also to create views, stored procedures, and triggers, in order to improve our SQL skills.

In this report, you will find every step of the project in the order we had to do them.











1

Caspar DIMANCHE & Camille SIMON – INT 3


II-   Steps and results of the project
a. First Session
i. Part 0: Preparation




































We can observe that even if there are 30 000 anounced students, in fact, there are many duplicates because when we delete them we obtain only 31 students.















2

Caspar DIMANCHE & Camille SIMON – INT 3




























































3

Caspar DIMANCHE & Camille SIMON – INT 3

























We chose to display also the year on the second screenshot, to make sure that our query was working.




















On the second screenshot, we executed the same query but with COUNT(student_name) insrtead of COUNT(DISTINCT student_name), to take into account the duplicates.


4

Caspar DIMANCHE & Camille SIMON – INT 3














As the result was the same as the people in each house having potion course, we tried on the second screenshot to see what happen if we didn’t delete the students duplicates. We found that it was coherent because when we did the sum, we obtained 30 000, which was our total of students with duplicates.









Every year is having every course.











Every student is studying every course









5

Caspar DIMANCHE & Camille SIMON – INT 3




















We chose to order the houses by alphabetical order, for a clearer result. As we can see, there are students enrolled for each course in any house.
























As we can see, every year, students are studying every course.


6

Caspar DIMANCHE & Camille SIMON – INT 3



























As each student is enrolled in each course, we couldn’t be sure our descending order was respected. That’s why, in the second screenshot, we traded all the COUNT(DISTINCT student_name) by some COUNT(student_name), in orrder to display the duplicates and verify the descending order of the list.








As we can see, the names of the houses are sorted.

ii. Part 1: Normalization

1. This database is not normalized because there is a big redundancy about the student_name, the same student is mentioned multiple times. In addition, the prefet is always associated with the same house, which causes another redundancy and the fact that if the house is updated, the preset should be updated too--> it can cause updating problems.



7

Caspar DIMANCHE & Camille SIMON – INT 3

2. student_name--> email house--> prefet

1NF is respected because all attributes are atomic.
2NF is not respected because if we consider the student_name as being the primary key, the prefet does not depend on the student_name, it depends on the house.
As 2NF is not respected, then 3NF is not respected either.

3. We thought that it will be a great idea to create a table ‘house’, linking each prefet to his house. We also wanted to create a table ‘study’ allowing us to associate students with their courses, and to do that, we first created a table ‘course’.

4. Title: Conceptual Data Model of the normalized schema












5. Here is now the Logical Data Model of our schema, built thanks to the 2nd and the 3rd transformation rules (the one for (X, 1)- (X, N) relations, and the one for (X, N)- (X, N) relations)

STUDENT = (ID_student, sudent_name, email, study_year, #ID_house) HOUSE = (ID_house, house, prefet)
COURSE = (ID_course, registered_course) STUDY = (#ID_student, #ID_course)

6. To back up our database, we will just copy the database and work with the copied one, called ‘projectnormalized’. We can see it with the query SHOW TABLES; and verify the attributes thanks to the query DESCRIBE projectnormalized;






7. Let’s normalize our database thanks to SQL queries.


8

Caspar DIMANCHE & Camille SIMON – INT 3















































Title: Table STUDENT



Title: Table HOUSE


Title: Table COURSE


9

Caspar DIMANCHE & Camille SIMON – INT 3

As we can see, our 3 tables respect the structure of the data model we conceived, and all of them have a primary key.



















Title: Table STUDENT



Title: Table STUDY
As we can see, the key ‘MUL’ signify that this is a foreign key. In the table study, the combination (ID_student, ID_course) is a primary key, but these 2 attributes are individually foreign key, one of the table STUDENT and the other for the table COURSE.


















10

Caspar DIMANCHE & Camille SIMON – INT 3














Here, we can see that for each student, there are hundreds of records that are absolutely the same, meaning they are records of the same student taking the same course. We want to delete all this duplicates, in order to normalize the table.











Now that we add a primary key to the table projectnormalized, we can delete all the duplicates thanks to the id.













The creation of the temporary table allows to compare it to the table where we want to delete the duplicates. We delete the temporary table after. Now, all the duplicates are deleted.


11

Caspar DIMANCHE & Camille SIMON – INT 3





















Title: Table HOUSE



















Title: Table HOUSE
Now, thanks to the SQL query above, we kept only one record for each house, more precisely the record with the lowest id. We will proceed the same way to fill the table COURSE.






12

Caspar DIMANCHE & Camille SIMON – INT 3


















Title: Table COURSE, containing many duplicates















Title: Table COURSE, after deleting all the duplicates We saw on the part 0 that there are only 3 courses, which is coherent to what we obtained here.
















13

Caspar DIMANCHE & Camille SIMON – INT 3

















This is the table STUDENT with all the attributes associated, even the foreign key of their house, but containing many duplicates, such as Levi Patel or Victoria Bailey (on the picture)























Here is now the table student without duplicates.






14

Caspar DIMANCHE & Camille SIMON – INT 3





























Table STUDENT







Table HOUSE





Table COURSE











15

Caspar DIMANCHE & Camille SIMON – INT 3














Table STUDY

Here is then the result of the normalization of the database. Thanks to the screenshots, we can check that everything is right. As we saw on the part 0, we have 4 houses and 3 courses. As we can see on the table STUDY, each student is taking each course, which was also what we found on the part 0. We got rid of all the duplicates and all the things that was preventing our database to be normalized.

b. Second session

Attention! For some reasons of deleting files and modifying tables because of the weeks of delay we had between the two sessions, we had to download again the database, which led the IDs of the courses, houses, and students to change. It is still the same and we can work on the normalized database we created, but the IDs are now different.

i. Part 1: Index

1. To create an index, we use the CREATE INDEX query. An index is important for optimizing query performance because it allows a faster data access for the indexed attributes, especially when the query using the index also use a SELECT, WHERE or JOIN operation. It is created on one or more columns of a table and stores a sorted copy of the data.

2.
















16

Caspar DIMANCHE & Camille SIMON – INT 3






















Output of the SHOW PROFILE query





Output of the SHOW PROFILES query





























17

Caspar DIMANCHE & Camille SIMON – INT 3










As we can see, thanks to the index the query executes faster. It was executed in 0.00033s before, and is now executed in 0.00022s.












When we ask to ignore the index, the query is even longer as before we create the index! It now takes 0.00074s

3. Measure the time of the query, add an index and measure again












The index is created.

This query allows to display for each house and course, the number of students enrolled both in this house and this course. The result is displayed by decreasing number of students. Here is the output of this query:



18

Caspar DIMANCHE & Camille SIMON – INT 3













We will now check the time took by the query to execute by using SHOW PROFILES, before it executes the CREATE INDEX:



Let’s now try the same but now with the index.



We see that now the query executes it 0.006 s with the index, knowing that the execution time without the index was 0.0012 s. It is faster with the index.






This query allows to display the name and email of students that does not have a course. There are no students like that in the database, so this SELECT query display an empty result table for us.




About the time of execution of the query, it took 0.0011 s.


Let’s now add an index on the student_name and check the SHOW PROFILE command.







19

Caspar DIMANCHE & Camille SIMON – INT 3


The index is well created.

Let’s now check the time the query takes to execute with the index.




The query now takes 0.0007 s to execute, which is really faster than the 0.0011 s it takes before creating the index.











This query allows to display the name of houses related to the number of students in each that are taking at least one of the 3 written courses. This results in fact to display the count of the students in each house because they all take at least one of these courses.







Above is the execution time taking by the query.
Let’s now create an index on ID_course in the COURSE table.






Let’s now find the execution time of the query now.

A little bit faster.


20

Caspar DIMANCHE & Camille SIMON – INT 3




















In this query, the first join selects the distinct course a student each year is studying. The second join selects all the different courses exiting per year.
Finally, this query in fact is printing the student’s name and the email of the students that are taking all the courses they could have taken for their study year.

Here is the output of this query, as well as its time execution:







Let’s now create an index on the email, show it exists and display again the execution time of the big query.








Thanks to the index, now the query executes a little bit faster than before.







21

Caspar DIMANCHE & Camille SIMON – INT 3

ii. Part 2: Views

1. A view is a virtual table based on the set of results of an SQL statement. A logical view is a set of SQL instructions that is used for joining multiple or single tables. A materialized view is mainly used in context to warehouse data.

2.


















































22

Caspar DIMANCHE & Camille SIMON – INT 3

3.












Let’s try to change the column containing the number of students in each house.
As there are already 10 students in our table for Gryffondor, we will try to change this number as 11.






This query doesn’t work because the student_count part of the query is obtained in the view by counting the students in each house. We can’t modify the count of students like that. If we want to have a new student to Gryffondor, we should add him correctly in the STUDENT table.

If the house_student_count was just a normal table and not a view, not related to a COUNT function, then we could have changed this number of people in the house. But if it was a COUNT function, then it will have not been possible.

iii. Part 3: Stored procedure and trigger

1. Stored procedure and triggers are some database objects that are used to automatize tasks in a database. They both need to be preceded and followed by DELIMITER statement to treat them as blocks of code.
A stored procedure is a set of SQL queries that can be saved and reused by calling them in a database. They are useful for doing repetitive or complex tasks.
A trigger is a block of code that is automatically executed in response to an event. It exists many events that can make a trigger do his thing, such as INSERT, UPDATE or DELETE. It is important to precise if the block of the trigger should be executed BEFORE or AFTER the event. Triggers are useful tools in automation, and they can also prevent problematic inserts in




23

Caspar DIMANCHE & Camille SIMON – INT 3

a database by avoiding the query to execute (for example, in the case of a night club registration, a trigger can refuse to add a new client to the database if this client is under 18).

2.






The table is created and is empty for the moment.































The table displays the number of students in each houses.

3.









24

Caspar DIMANCHE & Camille SIMON – INT 3





We add a student with an ID_house = 4, which means he belongs to Serpentard, which had 8 students before adding this one.






The view hasn’t been updated at this point.











Now, the new student has been added to the house Serpentard.

4.

With triggers, we can’t just keep the “TRUNCATE TABLE house_student_count_materialized;” line, it always provides us this error when trying to insert or delete a student:




Because of that problem, we chose to modify a little bit the stored procedure to make it work, because it wasn’t possible with the TRUNCATE statement. We replace it by a “DELETE FROM” statement:








25

Caspar DIMANCHE & Camille SIMON – INT 3















Tanks to this modification, with this new stored procedure refresh_house_student_count_materialized2, we were able to create the triggers and finish the project as we were supposed to.


















5.






The view is currently the same as it was.



26

Caspar DIMANCHE & Camille SIMON – INT 3
















The student is inserted in the house of ID_house = 1 (Gryffondor), which contained 10 students before adding this one.










The student has been added successfully to Gryffondor, thanks to the trigger. In fact, AFTER the insertion of the new student in the database, the trigger auto_update_on_insert has been called. This trigger call the procedure allowing the view to update, and that’s why, after adding this student, the view has been updated automatically.











Our student has been deleted in the table STUDENT. Now, the view should lose one student in the house Gryffondor. Let’s check this.





27

Caspar DIMANCHE & Camille SIMON – INT 3














The view has been modified thanks to the trigger, to deleted student does not belong anymore to the database. Our AFTER DELETE trigger is working perfectly.

III-  Conclusion

To conclude this project, we can say that doing it really improved our databases skills.
We understand better the functioning, from performing simple queries to starting to automatize some functionalities, including normalizing the whole database.
We learned about some ways to improve the rapidity of execution of the queries, for example with indexes. On our way to automatize the database, we became better at dealing with stored procedures and triggers to manage views.

We learned a lot, using the lab works we did in class as references, as well as internet when we encountered some difficulties. Our main difficulties were to delete the duplicates when normalizing the database, because it took us a time to understand that we had to create a temporary table to doing that. We also faced some problems with triggers, especially when using TRUNCATE TABLE in the stored procedure called by the trigger, but we overcame them thanks to some research, where we discovered that it was preferable to put another statement instead of TRUNCATE.

We think that the strong point of our work is the normalization of our database. We really focused on correctly applying the normalization rules, deleting all the duplicates to obtain the cleanest table possible. We tried to really understand what was expected from us for each question, and we were serious on putting screenshots in the report and detailing some subtilities when we needed to. If there is a point we could have improved, it will probably be the optimization of some queries. Even if we always reached our objectives in this project, we admit that some of our queries aren’t that optimal.

To do this project, we really worked in pair. We are a cohesive group, which allow us to do some serious work together. When one was performing the queries, the other was writing the report, and each time when facing a difficulty we discussed it, trying to solve our problem. We were always together when doing the project, so we didn’t need tools to share our code when working far from each other. As we both have a correct level in advanced databases, we managed to finish this project on time, with the results we expected.



28
